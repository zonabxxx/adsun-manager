#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ADSUN Database Schema Management
≈†tandardiz√°cia ≈°trukt√∫ry datab√°zy pre kompatibilitu s Airtable
"""

import streamlit as st
import sqlite3
from typing import Dict, List, Any
from datetime import datetime

# ≈†tandardizovan√° sch√©ma datab√°zy
DATABASE_SCHEMA = {
    'processes': {
        'airtable_name': 'Processes',
        'description': 'Firemn√© procesy a postupy',
        'columns': {
            'id': {'type': 'INTEGER', 'primary_key': True, 'airtable_type': 'auto_number'},
            'name': {'type': 'TEXT', 'required': True, 'airtable_type': 'single_line_text'},
            'category': {'type': 'TEXT', 'required': True, 'airtable_type': 'single_select'},
            'description': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'owner': {'type': 'TEXT', 'required': True, 'airtable_type': 'single_line_text'},
            'steps': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'frequency': {'type': 'TEXT', 'airtable_type': 'single_select'},
            'duration_minutes': {'type': 'INTEGER', 'airtable_type': 'number'},
            'priority': {'type': 'INTEGER', 'airtable_type': 'rating'},
            'automation_readiness': {'type': 'INTEGER', 'airtable_type': 'rating'},
            'tools': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'risks': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'improvements': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'is_active': {'type': 'BOOLEAN', 'default': True, 'airtable_type': 'checkbox'},
            'created_at': {'type': 'TIMESTAMP', 'default': 'CURRENT_TIMESTAMP', 'airtable_type': 'created_time'},
            'updated_at': {'type': 'TIMESTAMP', 'default': 'CURRENT_TIMESTAMP', 'airtable_type': 'last_modified_time'}
        }
    },
    
    'departments': {
        'airtable_name': 'Departments',
        'description': 'Firemn√© oddelenia a ich charakteristiky',
        'columns': {
            'id': {'type': 'INTEGER', 'primary_key': True, 'airtable_type': 'auto_number'},
            'name': {'type': 'TEXT', 'required': True, 'airtable_type': 'single_line_text'},
            'function': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'manager': {'type': 'TEXT', 'airtable_type': 'single_line_text'},
            'processes': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'staff_count': {'type': 'TEXT', 'airtable_type': 'single_line_text'},
            'competencies': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'collaboration': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'tools': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'challenges': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'success_metrics': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'created_at': {'type': 'TIMESTAMP', 'default': 'CURRENT_TIMESTAMP', 'airtable_type': 'created_time'},
            'updated_at': {'type': 'TIMESTAMP', 'default': 'CURRENT_TIMESTAMP', 'airtable_type': 'last_modified_time'}
        }
    },
    
    'positions': {
        'airtable_name': 'Positions',
        'description': 'Firemn√© poz√≠cie a ich popis',
        'columns': {
            'id': {'type': 'INTEGER', 'primary_key': True, 'airtable_type': 'auto_number'},
            'name': {'type': 'TEXT', 'required': True, 'airtable_type': 'single_line_text'},
            'description': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'department': {'type': 'TEXT', 'airtable_type': 'single_select'},
            'level': {'type': 'TEXT', 'airtable_type': 'single_select'},
            'responsibilities': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'requirements': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'tools_systems': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'work_time': {'type': 'TEXT', 'airtable_type': 'single_select'},
            'challenges': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'success_metrics': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'created_at': {'type': 'TIMESTAMP', 'default': 'CURRENT_TIMESTAMP', 'airtable_type': 'created_time'},
            'updated_at': {'type': 'TIMESTAMP', 'default': 'CURRENT_TIMESTAMP', 'airtable_type': 'last_modified_time'}
        }
    },
    
    'documentation_sessions': {
        'airtable_name': 'Documentation_Sessions',
        'description': 'Dokumentaƒçn√© sessions a AI interakcie',
        'columns': {
            'id': {'type': 'INTEGER', 'primary_key': True, 'airtable_type': 'auto_number'},
            'process_id': {'type': 'INTEGER', 'airtable_type': 'link_to_record'},
            'documented_by': {'type': 'TEXT', 'required': True, 'airtable_type': 'single_line_text'},
            'session_notes': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'ai_analysis': {'type': 'TEXT', 'airtable_type': 'long_text'},
            'created_at': {'type': 'TIMESTAMP', 'default': 'CURRENT_TIMESTAMP', 'airtable_type': 'created_time'}
        }
    }
}

# Mapovanie typov medzi SQLite a Airtable
AIRTABLE_TYPE_MAPPING = {
    'single_line_text': 'Text (single line)',
    'long_text': 'Long text',
    'number': 'Number',
    'rating': 'Rating (1-10)',
    'single_select': 'Single select',
    'checkbox': 'Checkbox',
    'auto_number': 'Autonumber',
    'created_time': 'Created time',
    'last_modified_time': 'Last modified time',
    'link_to_record': 'Link to another record'
}

def render_database_schema():
    """Render spr√°vy datab√°zovej sch√©my"""
    st.markdown("## üèóÔ∏è Sch√©ma datab√°zy")
    st.markdown("*≈†tandardizovan√° ≈°trukt√∫ra pre kompatibilitu s Airtable*")
    
    # Tabs pre r√¥zne sekcie
    tab1, tab2, tab3, tab4 = st.tabs(["üìä Prehƒæad sch√©my", "üîÑ Migr√°cia", "üìã Airtable mapping", "üõ†Ô∏è √öpravy"])
    
    with tab1:
        render_schema_overview()
    
    with tab2:
        render_migration_tools()
    
    with tab3:
        render_airtable_mapping()
    
    with tab4:
        render_schema_modifications()

def render_schema_overview():
    """Zobraz√≠ prehƒæad sch√©my"""
    st.markdown("### üìä Prehƒæad ≈°tandardizovanej sch√©my")
    
    for table_name, table_info in DATABASE_SCHEMA.items():
        with st.expander(f"üìã {table_info['airtable_name']} ({table_name})"):
            st.markdown(f"**Popis:** {table_info['description']}")
            
            # Vytvor DataFrame pre stƒ∫pce
            columns_data = []
            for col_name, col_info in table_info['columns'].items():
                # Konvertuj boolean hodnoty na stringy pre Arrow kompatibilitu
                default_value = col_info.get('default', '-')
                if isinstance(default_value, bool):
                    default_value = "‚úÖ √Åno" if default_value else "‚ùå Nie"
                elif default_value is None:
                    default_value = "-"
                else:
                    default_value = str(default_value)
                
                columns_data.append({
                    'Stƒ∫pec': col_name,
                    'SQLite typ': col_info['type'],
                    'Airtable typ': AIRTABLE_TYPE_MAPPING.get(col_info['airtable_type'], col_info['airtable_type']),
                    'Povinn√Ω': '‚úÖ' if col_info.get('required') else '‚ùå',
                    'Prim√°rny': 'üîë' if col_info.get('primary_key') else '-',
                    'Default': str(default_value)  # Zabezpeƒç√≠, ≈æe v≈°etko je string
                })
            
            import pandas as pd
            df = pd.DataFrame(columns_data)
            st.dataframe(df, use_container_width=True, hide_index=True)

def render_migration_tools():
    """N√°stroje pre migr√°ciu datab√°zy"""
    st.markdown("### üîÑ Migr√°cia datab√°zy")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üì• Import z aktu√°lnej DB")
        if st.button("üîç Analyzova≈• aktu√°lnu ≈°trukt√∫ru"):
            analyze_current_structure()
        
        if st.button("‚ö° Migrova≈• na nov√∫ sch√©mu"):
            migrate_to_new_schema()
    
    with col2:
        st.markdown("#### üì§ Export do Airtable")
        if st.button("üìã Generova≈• Airtable sch√©mu"):
            generate_airtable_schema()
        
        if st.button("üîó Vytvori≈• prepojenie"):
            create_airtable_connection()
    
    # Nov√° sekcia pre synchroniz√°ciu
    st.markdown("---")
    st.markdown("### üîÑ Synchroniz√°cia SQLite ‚Üî Airtable")
    
    api_key = st.session_state.get('airtable_api_key', '')
    base_id = st.session_state.get('airtable_base_id', '')
    
    if api_key and base_id:
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("üì§ SQLite ‚Üí Airtable"):
                sync_sqlite_to_airtable(api_key, base_id)
        
        with col2:
            if st.button("üì• Airtable ‚Üí SQLite"):
                sync_airtable_to_sqlite(api_key, base_id)
        
        with col3:
            if st.button("üîÑ Aktivova≈• Airtable re≈æim"):
                activate_airtable_mode(api_key, base_id)
    else:
        st.info("üí° Nastavte Airtable API √∫daje pre synchroniz√°ciu")

def analyze_current_structure():
    """Analyzuje aktu√°lnu ≈°trukt√∫ru datab√°zy"""
    try:
        with sqlite3.connect("adsun_processes.db") as conn:
            cursor = conn.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
            """)
            current_tables = [row[0] for row in cursor.fetchall()]
        
        st.markdown("#### üîç Aktu√°lne tabuƒæky v datab√°ze:")
        
        for table in current_tables:
            try:
                with sqlite3.connect("adsun_processes.db") as conn:
                    cursor = conn.execute(f"PRAGMA table_info(`{table}`)")
                    columns = cursor.fetchall()
                
                with st.expander(f"üìã {table}"):
                    st.write(f"**Poƒçet stƒ∫pcov:** {len(columns)}")
                    
                    # Porovnanie so ≈°tandardnou sch√©mou
                    if table in DATABASE_SCHEMA:
                        standard_cols = set(DATABASE_SCHEMA[table]['columns'].keys())
                        current_cols = set([col[1] for col in columns])
                        
                        missing = standard_cols - current_cols
                        extra = current_cols - standard_cols
                        
                        if missing:
                            st.warning(f"**Ch√Ωbaj√∫ce stƒ∫pce:** {', '.join(missing)}")
                        if extra:
                            st.info(f"**Navy≈°e stƒ∫pce:** {', '.join(extra)}")
                        if not missing and not extra:
                            st.success("‚úÖ ≈†trukt√∫ra je v s√∫lade so ≈°tandardom")
                    else:
                        st.warning("‚ö†Ô∏è Tabuƒæka nie je v ≈°tandardnej sch√©me")
                        
            except Exception as e:
                st.error(f"‚ùå Chyba anal√Ωzy tabuƒæky {table}: {e}")
                
    except Exception as e:
        st.error(f"‚ùå Chyba pripojenia k datab√°ze: {e}")

def migrate_to_new_schema():
    """Migruje datab√°zu na nov√∫ sch√©mu"""
    st.markdown("#### ‚ö° Migr√°cia na nov√∫ sch√©mu")
    
    with st.form("migration_form"):
        st.warning("‚ö†Ô∏è T√°to oper√°cia uprav√≠ ≈°trukt√∫ru datab√°zy. Odpor√∫ƒçame z√°lohu!")
        
        tables_to_migrate = st.multiselect(
            "Vyberte tabuƒæky na migr√°ciu:",
            list(DATABASE_SCHEMA.keys()),
            default=list(DATABASE_SCHEMA.keys())
        )
        
        backup_before = st.checkbox("Vytvori≈• z√°lohu pred migr√°ciou", value=True)
        
        if st.form_submit_button("üöÄ Spusti≈• migr√°ciu", type="primary"):
            if backup_before:
                create_database_backup()
            
            for table_name in tables_to_migrate:
                migrate_table(table_name)
            
            st.success("‚úÖ Migr√°cia dokonƒçen√°!")

def migrate_table(table_name: str):
    """Migruje konkr√©tnu tabuƒæku"""
    try:
        with sqlite3.connect("adsun_processes.db") as conn:
            schema = DATABASE_SCHEMA[table_name]
            
            # Vytvor SQL pre nov√∫ tabuƒæku
            create_sql = f"CREATE TABLE IF NOT EXISTS `{table_name}_new` ("
            column_definitions = []
            
            for col_name, col_info in schema['columns'].items():
                col_def = f"`{col_name}` {col_info['type']}"
                
                if col_info.get('primary_key'):
                    col_def += " PRIMARY KEY AUTOINCREMENT"
                elif col_info.get('required'):
                    col_def += " NOT NULL"
                
                if col_info.get('default'):
                    if col_info['default'] == 'CURRENT_TIMESTAMP':
                        col_def += " DEFAULT CURRENT_TIMESTAMP"
                    elif isinstance(col_info['default'], bool):
                        col_def += f" DEFAULT {1 if col_info['default'] else 0}"
                    else:
                        col_def += f" DEFAULT '{col_info['default']}'"
                
                column_definitions.append(col_def)
            
            create_sql += ", ".join(column_definitions) + ")"
            
            # Vytvor nov√∫ tabuƒæku
            conn.execute(create_sql)
            
            # Sk√∫s kop√≠rova≈• d√°ta z p√¥vodnej tabuƒæky ak existuje
            try:
                cursor = conn.execute(f"SELECT name FROM sqlite_master WHERE type='table' AND name='{table_name}'")
                if cursor.fetchone():
                    # Z√≠skaj spoloƒçn√© stƒ∫pce
                    cursor = conn.execute(f"PRAGMA table_info(`{table_name}`)")
                    old_columns = [row[1] for row in cursor.fetchall()]
                    new_columns = list(schema['columns'].keys())
                    common_columns = [col for col in old_columns if col in new_columns]
                    
                    if common_columns:
                        columns_str = ", ".join([f"`{col}`" for col in common_columns])
                        conn.execute(f"""
                            INSERT INTO `{table_name}_new` ({columns_str})
                            SELECT {columns_str} FROM `{table_name}`
                        """)
                    
                    # Premenuj tabuƒæky
                    conn.execute(f"DROP TABLE `{table_name}`")
                    conn.execute(f"ALTER TABLE `{table_name}_new` RENAME TO `{table_name}`")
                else:
                    conn.execute(f"ALTER TABLE `{table_name}_new` RENAME TO `{table_name}`")
                    
            except Exception as e:
                st.warning(f"‚ö†Ô∏è Nemo≈æno kop√≠rova≈• d√°ta pre {table_name}: {e}")
                conn.execute(f"ALTER TABLE `{table_name}_new` RENAME TO `{table_name}`")
            
            conn.commit()
            st.success(f"‚úÖ Tabuƒæka {table_name} migrovan√°")
            
    except Exception as e:
        st.error(f"‚ùå Chyba migr√°cie {table_name}: {e}")

def create_database_backup():
    """Vytvor√≠ z√°lohu datab√°zy"""
    try:
        import shutil
        backup_name = f"adsun_processes_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db"
        shutil.copy2("adsun_processes.db", backup_name)
        st.success(f"‚úÖ Z√°loha vytvoren√°: {backup_name}")
    except Exception as e:
        st.error(f"‚ùå Chyba z√°lohy: {e}")

def render_airtable_mapping():
    """Zobraz√≠ mapov√°n√≠ pre Airtable"""
    st.markdown("### üìã Mapovanie pre Airtable")
    
    st.markdown("#### üîó Odpor√∫ƒçan√° ≈°trukt√∫ra Airtable Base:")
    
    for table_name, table_info in DATABASE_SCHEMA.items():
        with st.expander(f"üìä {table_info['airtable_name']}"):
            st.markdown(f"**Popis:** {table_info['description']}")
            
            # Airtable polia
            st.markdown("**Polia v Airtable:**")
            for col_name, col_info in table_info['columns'].items():
                airtable_type = AIRTABLE_TYPE_MAPPING.get(col_info['airtable_type'], col_info['airtable_type'])
                st.write(f"‚Ä¢ **{col_name}**: {airtable_type}")

def generate_airtable_schema():
    """Generuje sch√©mu pre Airtable"""
    st.markdown("#### üìã Airtable sch√©ma (JSON)")
    
    airtable_schema = {}
    for table_name, table_info in DATABASE_SCHEMA.items():
        airtable_schema[table_info['airtable_name']] = {
            'description': table_info['description'],
            'fields': {}
        }
        
        for col_name, col_info in table_info['columns'].items():
            airtable_schema[table_info['airtable_name']]['fields'][col_name] = {
                'type': col_info['airtable_type'],
                'description': AIRTABLE_TYPE_MAPPING.get(col_info['airtable_type'], ''),
                'required': col_info.get('required', False)
            }
    
    import json
    schema_json = json.dumps(airtable_schema, indent=2, ensure_ascii=False)
    
    st.code(schema_json, language='json')
    
    st.download_button(
        label="üì• Stiahnu≈• sch√©mu",
        data=schema_json,
        file_name=f"airtable_schema_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
        mime='application/json'
    )

def create_airtable_connection():
    """Vytvor√≠ prepojenie s Airtable"""
    st.markdown("#### üîó Prepojenie s Airtable")
    
    # Naƒç√≠taj API √∫daje zo session state
    api_key = st.session_state.get('airtable_api_key', '')
    base_id = st.session_state.get('airtable_base_id', '')
    
    if not api_key or not base_id:
        st.warning("‚ö†Ô∏è Pros√≠m nastavte Airtable API kƒæ√∫ƒç a Base ID v boƒçnom paneli")
        
        # R√Ωchla pomoc pre nastavenie
        with st.expander("‚ùì Ako z√≠ska≈• API √∫daje"):
            st.markdown("""
            **1. API kƒæ√∫ƒç:**
            - Idite na: https://airtable.com/create/tokens
            - Vytvorte nov√Ω token s opr√°vneniami: `data.records:read`, `data.records:write`, `schema.bases:read`
            - Skop√≠rujte token
            
            **2. Base ID:**
            - Otvorte va≈°u Airtable base v prehliadaƒçi
            - Z URL skop√≠rujte ƒças≈• zaƒç√≠naj√∫cu 'app' (napr. appXXXXXXXXXXXXXX)
            
            **3. Nastavte v aplik√°cii:**
            - Boƒçn√Ω panel ‚Üí Datab√°za ‚Üí Airtable (cloud)
            - Vlo≈æte API kƒæ√∫ƒç a Base ID
            """)
        return
    
    st.info(f"üîë **API Key:** ...{api_key[-6:] if len(api_key) > 6 else '***'}")
    st.info(f"üè¢ **Base ID:** {base_id}")
    
    # R√Ωchky status check
    with st.container():
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("‚ö° R√Ωchly test", help="Z√°kladn√Ω test pripojenia", key="quick_test_btn"):
                st.session_state.run_quick_test = True
                st.session_state.show_detailed_diagnostic = False
        
        with col2:
            if st.button("üîß Detailn√° diagnostika", help="Kompletn√° diagnostika s rie≈°eniami", key="detailed_diag_btn"):
                st.session_state.show_detailed_diagnostic = True
                st.session_state.run_quick_test = False
    
    # Jednoduch√Ω test tlaƒçidla
    if st.button("üß™ Test tlaƒçidla", key="simple_test_btn"):
        st.success("‚úÖ Tlaƒçidlo funguje!")
        st.write(f"API Key: {api_key[:10]}...")
        st.write(f"Base ID: {base_id}")
    
    # Spusti r√Ωchly test ak je po≈æadovan√Ω
    if st.session_state.get('run_quick_test', False):
        st.markdown("### ‚ö° R√Ωchly test v√Ωsledky")
        try:
            quick_airtable_test(api_key, base_id)
        except Exception as e:
            st.error(f"‚ùå Chyba r√Ωchleho testu: {e}")
            st.code(str(e))
        
        if st.button("üîÑ Spusti≈• znovu", key="rerun_quick_btn"):
            st.session_state.run_quick_test = True
            st.rerun()
        
        if st.button("üîô Skry≈• v√Ωsledky", key="hide_quick_btn"):
            st.session_state.run_quick_test = False
            st.rerun()
    
    # Zobraz detailn√∫ diagnostiku ak je po≈æadovan√°
    if st.session_state.get('show_detailed_diagnostic', False):
        st.markdown("### üîß Detailn√° diagnostika")
        try:
            test_airtable_connection(api_key, base_id)
        except Exception as e:
            st.error(f"‚ùå Chyba detailnej diagnostiky: {e}")
            st.code(str(e))
        
        if st.button("üîô Skry≈• diagnostiku", key="hide_diag_btn"):
            st.session_state.show_detailed_diagnostic = False
            st.rerun()
    
    # Test tlaƒçidl√°
    st.markdown("---")
    st.markdown("#### üß™ Testovac√≠ panel")
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üîç Test pripojenia"):
            test_airtable_connection(api_key, base_id)
    
    with col2:
        if st.button("üìä Test ƒç√≠tania"):
            test_airtable_read(api_key, base_id)
    
    with col3:
        if st.button("üíæ Test z√°pisu"):
            test_airtable_write(api_key, base_id)
    
    # N√°vod na setup
    with st.expander("üìã N√°vod na nastavenie Airtable"):
        st.markdown("""
        **Kroky pre prepojenie:**
        1. **Vytvorte Airtable Base** s nasleduj√∫cimi tabuƒækami:
           - `Processes` - hlavn√© procesy
           - `Departments` - oddelenia  
           - `Positions` - poz√≠cie
           - `Documentation_Sessions` - AI sessions
        
        2. **Vytvorte polia podƒæa sch√©my** (viƒè tab "Airtable mapping")
        
        3. **Z√≠skajte API √∫daje:**
           - API kƒæ√∫ƒç: https://airtable.com/create/tokens
           - Base ID: z URL va≈°ej Base (appXXXXXX)
        
        4. **Nastavte v aplik√°cii** (boƒçn√Ω panel)
        
        5. **Otestujte pripojenie** tlaƒçidlami vy≈°≈°ie
        """)
    
    # Troubleshooting sekcia
    with st.expander("üîß Rie≈°enie probl√©mov"):
        st.markdown("""
        ### üö® Najƒçastej≈°ie probl√©my a rie≈°enia:
        
        **‚ùå "Neautorizovan√Ω pr√≠stup"**
        - Skontrolujte API kƒæ√∫ƒç na https://airtable.com/create/tokens
        - Overte ≈æe token nie je expirovan√Ω
        - Vytvorte nov√Ω token ak potrebn√©
        
        **‚ùå "Nedostatoƒçn√© opr√°vnenia"** 
        - API token mus√≠ ma≈• tieto opr√°vnenia:
          - `data.records:read` - ƒç√≠tanie z√°znamov
          - `data.records:write` - z√°pis z√°znamov  
          - `schema.bases:read` - ƒç√≠tanie ≈°trukt√∫ry
        
        **‚ùå "Base nen√°jden√°"**
        - Base ID mus√≠ zaƒç√≠na≈• 'app' a ma≈• 17 znakov
        - Skop√≠rujte z URL: `https://airtable.com/appXXXXXXXXXXXXXX/...`
        - Overte ≈æe m√°te pr√≠stup k tejto base
        
        **‚ùå "Ch√Ωbaj√∫ce tabuƒæky"**
        - V Airtable base vytvorte tieto tabuƒæky:
          - `Processes` (povinn√°)
          - `Departments` 
          - `Positions`
          - `Documentation_Sessions`
        
        **‚ùå "Timeout/Pripojenie"**
        - Skontrolujte internetov√© pripojenie
        - Sk√∫ste znovu o chv√≠ƒæu (mo≈æn√Ω doƒçasn√Ω probl√©m)
        - Overte firewall nastavenia
        
        **üí° Tip:** Pou≈æite "‚ö° R√Ωchly test" pre r√Ωchlu diagnostiku
        """)
    
    # Status indik√°tor
    if st.session_state.get('airtable_connection_status'):
        status = st.session_state.airtable_connection_status
        if status == 'success':
            st.success("üü¢ Airtable pripojenie akt√≠vne")
        elif status == 'warning':
            st.warning("üü° Airtable pripojenie s obmedzeniami")
        elif status == 'error':
            st.error("üî¥ Airtable pripojenie neakt√≠vne")

def test_airtable_connection(api_key: str, base_id: str):
    """Testuje z√°kladn√© pripojenie k Airtable"""
    try:
        from airtable_connector import AirtableConnector
        
        with st.spinner("üîç Testujem pripojenie..."):
            
            # Detailn√° diagnostika
            st.markdown("### üîç Detailn√° diagnostika")
            
            # 1. Valid√°cia API √∫dajov
            st.write("**1. Valid√°cia API √∫dajov:**")
            if len(api_key) < 10:
                st.error("‚ùå API kƒæ√∫ƒç je pr√≠li≈° kr√°tky")
                return
            else:
                st.success(f"‚úÖ API kƒæ√∫ƒç: {len(api_key)} znakov")
            
            if not base_id.startswith('app') or len(base_id) != 17:
                st.error("‚ùå Base ID m√° nespr√°vny form√°t (oƒçak√°va sa appXXXXXXXXXXXXXX)")
                return
            else:
                st.success(f"‚úÖ Base ID: {base_id}")
            
            # 2. Test z√°kladn√©ho API pripojenia
            st.write("**2. Test z√°kladn√©ho pripojenia:**")
            try:
                import requests
                
                headers = {
                    "Authorization": f"Bearer {api_key}",
                    "Content-Type": "application/json"
                }
                
                # Test s jednoduch√Ωm API volan√≠m
                response = requests.get(
                    f"https://api.airtable.com/v0/meta/bases/{base_id}",
                    headers=headers,
                    timeout=15
                )
                
                st.write(f"Status k√≥d: {response.status_code}")
                
                if response.status_code == 200:
                    st.success("‚úÖ Z√°kladn√© pripojenie √∫spe≈°n√©!")
                    
                    # Zobraz inform√°cie o base
                    base_data = response.json()
                    st.info(f"üìä Base: {base_data.get('name', 'Bez n√°zvu')}")
                    
                elif response.status_code == 401:
                    st.error("‚ùå Neautorizovan√Ω pr√≠stup - nespr√°vny API kƒæ√∫ƒç")
                    st.write("**Rie≈°enie:** Overte API kƒæ√∫ƒç na https://airtable.com/create/tokens")
                    return
                elif response.status_code == 403:
                    st.error("‚ùå Zak√°zan√Ω pr√≠stup - nedostatoƒçn√© opr√°vnenia")
                    st.write("**Rie≈°enie:** API kƒæ√∫ƒç mus√≠ ma≈• opr√°vnenia 'data.records:read' a 'schema.bases:read'")
                    return
                elif response.status_code == 404:
                    st.error("‚ùå Base nen√°jden√° - nespr√°vny Base ID")
                    st.write("**Rie≈°enie:** Skontrolujte Base ID v URL va≈°ej Airtable base")
                    return
                else:
                    st.error(f"‚ùå Neoƒçak√°van√Ω status k√≥d: {response.status_code}")
                    if response.text:
                        st.code(response.text)
                    return
                    
            except requests.exceptions.Timeout:
                st.error("‚ùå Timeout - pripojenie trv√° pr√≠li≈° dlho")
                st.write("**Rie≈°enie:** Skontrolujte internetov√© pripojenie")
                return
            except requests.exceptions.ConnectionError:
                st.error("‚ùå Chyba pripojenia - nemo≈æno sa spoji≈• s Airtable")
                st.write("**Rie≈°enie:** Skontrolujte internetov√© pripojenie a firewall")
                return
            except Exception as e:
                st.error(f"‚ùå Neoƒçak√°van√° chyba: {e}")
                return
            
            # 3. Test AirtableConnector triedy
            st.write("**3. Test AirtableConnector:**")
            connector = AirtableConnector(api_key, base_id)
            
            if connector.test_connection():
                st.success("‚úÖ AirtableConnector pripojenie √∫spe≈°n√©!")
                
                # 4. Test z√≠skania tabuliek
                st.write("**4. Test z√≠skania tabuliek:**")
                try:
                    response = requests.get(
                        f"https://api.airtable.com/v0/meta/bases/{base_id}/tables",
                        headers=headers,
                        timeout=10
                    )
                    
                    if response.status_code == 200:
                        tables_data = response.json()
                        tables = tables_data.get('tables', [])
                        
                        st.success(f"‚úÖ N√°jden√Ωch {len(tables)} tabuliek v base:")
                        for table in tables[:5]:  # Zobraz prv√Ωch 5
                            st.write(f"‚Ä¢ **{table['name']}** ({len(table.get('fields', []))} pol√≠)")
                        
                        # Kontrola oƒçak√°van√Ωch tabuliek
                        table_names = [t['name'] for t in tables]
                        expected_tables = ['Processes', 'Departments', 'Positions', 'Documentation_Sessions']
                        missing_tables = [t for t in expected_tables if t not in table_names]
                        
                        if missing_tables:
                            st.warning(f"‚ö†Ô∏è Ch√Ωbaj√∫ce tabuƒæky: {', '.join(missing_tables)}")
                            st.info("üí° Vytvorte ch√Ωbaj√∫ce tabuƒæky v Airtable podƒæa sch√©my")
                            
                            # Uk√°≈æ ako vytvori≈• tabuƒæky
                            with st.expander("üìã Ako vytvori≈• ch√Ωbaj√∫ce tabuƒæky"):
                                st.markdown("""
                                **V Airtable base vytvorte tieto tabuƒæky:**
                                
                                **Processes:**
                                - Process Name (Single line text)
                                - Category (Single select: obchod, HR, administrat√≠va, IT, v√Ωroba)
                                - Owner (Single line text)
                                - Frequency (Single select: denne, t√Ω≈ædenne, mesaƒçne, obƒças)
                                - Duration (min) (Number)
                                
                                **Departments, Positions, Documentation_Sessions:**
                                - Vytvorte pr√°zdne tabuƒæky s t√Ωmito n√°zvami
                                - Polia sa pridaj√∫ automaticky pri prvom z√°pise
                                """)
                        else:
                            st.success("‚úÖ V≈°etky oƒçak√°van√© tabuƒæky n√°jden√©!")
                            
                        # 5. Test ƒç√≠tania d√°t
                        st.write("**5. Test ƒç√≠tania d√°t z tabuƒæky Processes:**")
                        if 'Processes' in table_names:
                            try:
                                processes = connector.get_processes(limit=1)
                                if processes:
                                    st.success(f"‚úÖ Naƒç√≠tan√Ω {len(processes)} proces")
                                else:
                                    st.info("üì≠ Tabuƒæka Processes je pr√°zdna (OK)")
                            except Exception as e:
                                st.warning(f"‚ö†Ô∏è Chyba ƒç√≠tania procesov: {e}")
                        else:
                            st.warning("‚ö†Ô∏è Tabuƒæka Processes neexistuje")
                            
                    else:
                        st.error(f"‚ùå Nemo≈æno naƒç√≠ta≈• tabuƒæky (status: {response.status_code})")
                        
                except Exception as e:
                    st.error(f"‚ùå Chyba naƒç√≠tavania tabuliek: {e}")
                    
            else:
                st.error("‚ùå AirtableConnector test ne√∫spe≈°n√Ω")
                
    except ImportError:
        st.error("‚ùå Modul airtable_connector nen√°jden√Ω")
    except Exception as e:
        st.error(f"‚ùå Neoƒçak√°van√° chyba diagnostiky: {e}")
        st.code(str(e))

def test_airtable_read(api_key: str, base_id: str):
    """Testuje ƒç√≠tanie d√°t z Airtable"""
    try:
        from airtable_connector import AirtableConnector
        
        with st.spinner("üìä Testujem ƒç√≠tanie d√°t..."):
            connector = AirtableConnector(api_key, base_id)
            
            # Test ƒç√≠tania procesov
            processes = connector.get_processes(limit=5)
            
            if processes:
                st.success(f"‚úÖ Naƒç√≠tan√Ωch {len(processes)} procesov z Airtable!")
                
                # Zobraz prv√© procesy
                for i, process in enumerate(processes[:3]):
                    with st.expander(f"üìã {process.get('name', 'Bez n√°zvu')}"):
                        col1, col2 = st.columns(2)
                        
                        with col1:
                            st.write(f"**ID:** {process.get('id', 'N/A')}")
                            st.write(f"**Kateg√≥ria:** {process.get('category', 'N/A')}")
                            st.write(f"**Vlastn√≠k:** {process.get('owner', 'N/A')}")
                        
                        with col2:
                            st.write(f"**Frekvencia:** {process.get('frequency', 'N/A')}")
                            st.write(f"**Trvanie:** {process.get('duration_minutes', 0)} min")
                            st.write(f"**Automatiz√°cia:** {process.get('automation_readiness', 0)}/5")
                
            else:
                st.warning("‚ö†Ô∏è ≈Ωiadne procesy nen√°jden√© alebo tabuƒæka 'Processes' neexistuje")
                st.info("üí° Vytvorte tabuƒæku 'Processes' v Airtable s polami podƒæa sch√©my")
                
    except Exception as e:
        st.error(f"‚ùå Chyba ƒç√≠tania z Airtable: {e}")

def test_airtable_write(api_key: str, base_id: str):
    """Testuje z√°pis d√°t do Airtable"""
    try:
        from airtable_connector import AirtableConnector
        
        st.markdown("**‚ö†Ô∏è Test z√°pisu vytvor√≠ testovac√≠ z√°znam v Airtable**")
        
        if st.button("‚úÖ Pokraƒçova≈• s testom z√°pisu", type="primary"):
            with st.spinner("üíæ Testujem z√°pis d√°t..."):
                connector = AirtableConnector(api_key, base_id)
                
                # Vytvor testovac√≠ proces
                test_process = {
                    "name": f"üß™ Test proces {datetime.now().strftime('%H:%M:%S')}",
                    "category": "test",
                    "owner": "ADSUN Test",
                    "frequency": "test",
                    "duration_minutes": 5,
                    "priority": "n√≠zka",
                    "automation_readiness": 1,
                    "success_criteria": "Test √∫spe≈°n√Ω",
                    "common_problems": "≈Ωiadne",
                    "mentioned_systems": ["ADSUN"]
                }
                
                # Pok√∫s sa ulo≈æi≈•
                process_id = connector.save_process(test_process)
                
                if process_id:
                    st.success(f"‚úÖ Test proces ulo≈æen√Ω! ID: {process_id}")
                    
                    # Test session ulo≈æenia
                    test_session = {
                        "documenter": "ADSUN Test",
                        "step": 1,
                        "question": "Test ot√°zka?",
                        "response": "Test odpoveƒè",
                        "analysis": {"test": True},
                        "ai_powered": True,
                        "timestamp": datetime.now().isoformat(),
                        "completeness_score": 10
                    }
                    
                    session_id = connector.save_documentation_session(process_id, test_session)
                    
                    if session_id:
                        st.success(f"‚úÖ Test session ulo≈æen√°! ID: {session_id}")
                        st.info("üßπ M√¥≈æete vymaza≈• test z√°znamy z Airtable")
                    else:
                        st.warning("‚ö†Ô∏è Process ulo≈æen√Ω, ale session sa nepodarilo ulo≈æi≈•")
                        
                else:
                    st.error("‚ùå Nepodarilo sa ulo≈æi≈• test proces")
                    st.write("**Mo≈æn√© pr√≠ƒçiny:**")
                    st.write("‚Ä¢ Tabuƒæka 'Processes' neexistuje")
                    st.write("‚Ä¢ Ch√Ωbaj√∫ce alebo nespr√°vne polia")
                    st.write("‚Ä¢ Nedostatoƒçn√© opr√°vnenia")
                    
    except Exception as e:
        st.error(f"‚ùå Chyba z√°pisu do Airtable: {e}")
        st.write("**Debug info:**")
        st.code(str(e))

def render_schema_modifications():
    """N√°stroje na √∫pravu sch√©my"""
    st.markdown("### üõ†Ô∏è √öpravy sch√©my")
    
    st.markdown("#### ‚ûï Prida≈• nov√© pole")
    
    with st.form("add_field_form"):
        table_name = st.selectbox("Tabuƒæka:", list(DATABASE_SCHEMA.keys()))
        field_name = st.text_input("N√°zov poƒæa:")
        field_type = st.selectbox("SQLite typ:", ['TEXT', 'INTEGER', 'REAL', 'BOOLEAN', 'TIMESTAMP'])
        airtable_type = st.selectbox("Airtable typ:", list(AIRTABLE_TYPE_MAPPING.keys()))
        is_required = st.checkbox("Povinn√© pole")
        
        if st.form_submit_button("‚ûï Prida≈• pole"):
            add_custom_field(table_name, field_name, field_type, airtable_type, is_required)

def add_custom_field(table_name: str, field_name: str, field_type: str, airtable_type: str, is_required: bool):
    """Prid√° vlastn√© pole do sch√©my"""
    try:
        # Pridaj do runtime sch√©my
        DATABASE_SCHEMA[table_name]['columns'][field_name] = {
            'type': field_type,
            'required': is_required,
            'airtable_type': airtable_type
        }
        
        # Pridaj do datab√°zy
        with sqlite3.connect("adsun_processes.db") as conn:
            required_clause = "NOT NULL" if is_required else ""
            conn.execute(f"ALTER TABLE `{table_name}` ADD COLUMN `{field_name}` {field_type} {required_clause}")
            conn.commit()
        
        st.success(f"‚úÖ Pole {field_name} pridan√© do {table_name}")
        
    except Exception as e:
        st.error(f"‚ùå Chyba prid√°vania poƒæa: {e}")

# Export sch√©my pre ƒèal≈°ie pou≈æitie
def get_standardized_schema():
    """Vracia ≈°tandardizovan√∫ sch√©mu"""
    return DATABASE_SCHEMA

def quick_airtable_test(api_key: str, base_id: str):
    """R√Ωchly test Airtable pripojenia"""
    
    st.write("üîç **Test spusten√Ω!**")
    
    # Debug info
    st.write("üîç **Debug info:**")
    st.write(f"API Key dƒ∫≈æka: {len(api_key) if api_key else 0}")
    st.write(f"Base ID: {base_id}")
    
    if not api_key or not base_id:
        st.error("‚ùå Ch√Ωbaj√∫ API √∫daje!")
        return
    
    if len(api_key) < 10:
        st.error("‚ùå API kƒæ√∫ƒç je pr√≠li≈° kr√°tky!")
        return
        
    if not base_id.startswith('app'):
        st.error("‚ùå Base ID mus√≠ zaƒç√≠na≈• 'app'!")
        return
        
    try:
        st.write("üì° **Importujem requests modul...**")
        import requests
        st.success("‚úÖ Requests modul naƒç√≠tan√Ω")
        
        st.write("üì° **Pripravujem API volanie...**")
        headers = {"Authorization": f"Bearer {api_key}"}
        url = f"https://api.airtable.com/v0/meta/bases/{base_id}"
        
        st.write(f"üîó URL: {url}")
        st.write("üì° **Vol√°m Airtable API...**")
        
        # Test z√°kladn√©ho pripojenia
        response = requests.get(url, headers=headers, timeout=10)
        
        st.write(f"üîç **Odpoveƒè prijat√°. Status k√≥d: {response.status_code}**")
        
        if response.status_code == 200:
            st.success("‚úÖ Pripojenie √∫spe≈°n√©!")
            try:
                base_data = response.json()
                st.info(f"üìä Base: {base_data.get('name', 'Bez n√°zvu')}")
            except Exception as e:
                st.warning(f"‚ö†Ô∏è Nemo≈æno parsova≈• JSON: {e}")
            
            # Test tabuliek
            st.write("üìã **Testujem tabuƒæky...**")
            try:
                tables_url = f"https://api.airtable.com/v0/meta/bases/{base_id}/tables"
                tables_response = requests.get(tables_url, headers=headers, timeout=10)
                
                if tables_response.status_code == 200:
                    tables_data = tables_response.json()
                    tables = tables_data.get('tables', [])
                    st.success(f"‚úÖ N√°jden√Ωch {len(tables)} tabuliek")
                    
                    # Zobraz n√°zvy tabuliek
                    if tables:
                        st.write("**Existuj√∫ce tabuƒæky:**")
                        for table in tables[:5]:  # Max 5
                            st.write(f"‚Ä¢ {table['name']}")
                    
                    # Kontrola oƒçak√°van√Ωch tabuliek
                    expected = ['Processes', 'Departments', 'Positions', 'Documentation_Sessions']
                    existing = [t['name'] for t in tables]
                    missing = [t for t in expected if t not in existing]
                    
                    if missing:
                        st.warning(f"‚ö†Ô∏è Ch√Ωbaj√∫ce tabuƒæky: {', '.join(missing)}")
                        st.info("üí° V Airtable vytvorte tieto tabuƒæky:")
                        for table in missing:
                            st.write(f"   ‚Ä¢ `{table}`")
                    else:
                        st.success("‚úÖ V≈°etky potrebn√© tabuƒæky existuj√∫!")
                        
                else:
                    st.error(f"‚ùå Chyba naƒç√≠tavania tabuliek: {tables_response.status_code}")
                    
            except Exception as e:
                st.error(f"‚ùå Chyba testovania tabuliek: {e}")
                
        elif response.status_code == 401:
            st.error("‚ùå Neautorizovan√Ω pr√≠stup - nespr√°vny API kƒæ√∫ƒç")
            st.info("üí° Skontrolujte API kƒæ√∫ƒç na: https://airtable.com/create/tokens")
        elif response.status_code == 403:
            st.error("‚ùå Nedostatoƒçn√© opr√°vnenia")
            st.info("üí° API token mus√≠ ma≈• opr√°vnenia: data.records:read, data.records:write, schema.bases:read")
        elif response.status_code == 404:
            st.error("‚ùå Base nen√°jden√°")
            st.info("üí° Skontrolujte Base ID - mus√≠ zaƒç√≠na≈• 'app' a ma≈• 17 znakov")
        else:
            st.error(f"‚ùå Neoƒçak√°van√Ω status k√≥d: {response.status_code}")
            try:
                error_text = response.text[:300] if response.text else "≈Ωiadna odpoveƒè"
                st.code(error_text)
            except:
                st.write("Nemo≈æno zobrazi≈• chybov√∫ spr√°vu")
                
    except requests.exceptions.Timeout:
        st.error("‚ùå Timeout - pripojenie trv√° pr√≠li≈° dlho")
        st.info("üí° Skontrolujte internetov√© pripojenie")
    except requests.exceptions.ConnectionError:
        st.error("‚ùå Probl√©m s internetov√Ωm pripojen√≠m")
        st.info("üí° Skontrolujte internetov√© pripojenie alebo firewall")
    except ImportError:
        st.error("‚ùå Ch√Ωba modul requests")
        st.info("üí° Nain≈°talujte: pip install requests")
    except Exception as e:
        st.error(f"‚ùå Neoƒçak√°van√° chyba: {e}")
        st.write("**Debug inform√°cie:**")
        st.code(str(e))
        
        import traceback
        st.write("**Kompletn√Ω error:**")
        st.code(traceback.format_exc())

def sync_sqlite_to_airtable(api_key: str, base_id: str):
    """Synchronizuje d√°ta z SQLite do Airtable"""
    try:
        from airtable_connector import AirtableConnector
        import sqlite3
        
        with st.spinner("üì§ Synchronizujem SQLite ‚Üí Airtable..."):
            connector = AirtableConnector(api_key, base_id)
            
            if not connector.test_connection():
                st.error("‚ùå Airtable pripojenie ne√∫spe≈°n√©!")
                return
            
            # Synchronizuj procesy
            with sqlite3.connect("adsun_processes.db") as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute("SELECT * FROM processes WHERE is_active = 1 LIMIT 10")
                processes = [dict(row) for row in cursor.fetchall()]
            
            if processes:
                uploaded_count = 0
                for process in processes:
                    # Transformuj na Airtable form√°t
                    airtable_process = {
                        "name": process.get('name', ''),
                        "category": process.get('category', 'nezhodnoten√©'),
                        "owner": process.get('owner', ''),
                        "frequency": process.get('frequency', 'nezhodnoten√©'),
                        "duration_minutes": process.get('duration_minutes', 0),
                        "priority": process.get('priority', 'stredn√°'),
                        "automation_readiness": process.get('automation_readiness', 0),
                        "success_criteria": process.get('success_criteria', ''),
                        "common_problems": process.get('common_problems', ''),
                        "mentioned_systems": []
                    }
                    
                    if connector.save_process(airtable_process):
                        uploaded_count += 1
                
                st.success(f"‚úÖ Synchronizovan√Ωch {uploaded_count}/{len(processes)} procesov!")
            else:
                st.info("üì≠ ≈Ωiadne procesy na synchroniz√°ciu")
                
    except Exception as e:
        st.error(f"‚ùå Chyba synchroniz√°cie: {e}")

def sync_airtable_to_sqlite(api_key: str, base_id: str):
    """Synchronizuje d√°ta z Airtable do SQLite"""
    try:
        from airtable_connector import AirtableConnector
        import sqlite3
        
        with st.spinner("üì• Synchronizujem Airtable ‚Üí SQLite..."):
            connector = AirtableConnector(api_key, base_id)
            
            if not connector.test_connection():
                st.error("‚ùå Airtable pripojenie ne√∫spe≈°n√©!")
                return
            
            # Naƒç√≠taj procesy z Airtable
            airtable_processes = connector.get_processes(limit=50)
            
            if airtable_processes:
                imported_count = 0
                
                with sqlite3.connect("adsun_processes.db") as conn:
                    for process in airtable_processes:
                        try:
                            # Skontroluj ƒçi proces u≈æ existuje
                            cursor = conn.execute(
                                "SELECT id FROM processes WHERE name = ? AND owner = ?",
                                (process.get('name', ''), process.get('owner', ''))
                            )
                            
                            if not cursor.fetchone():
                                # Vlo≈æ nov√Ω proces
                                conn.execute("""
                                    INSERT INTO processes (
                                        name, category, owner, frequency, duration_minutes,
                                        priority, automation_readiness, success_criteria,
                                        common_problems, is_active, created_at
                                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 1, datetime('now'))
                                """, (
                                    process.get('name', ''),
                                    process.get('category', ''),
                                    process.get('owner', ''),
                                    process.get('frequency', ''),
                                    process.get('duration_minutes', 0),
                                    process.get('priority', ''),
                                    process.get('automation_readiness', 0),
                                    process.get('success_criteria', ''),
                                    process.get('common_problems', '')
                                ))
                                imported_count += 1
                        except Exception as e:
                            st.warning(f"‚ö†Ô∏è Chyba importu procesu {process.get('name', '')}: {e}")
                    
                    conn.commit()
                
                st.success(f"‚úÖ Importovan√Ωch {imported_count}/{len(airtable_processes)} nov√Ωch procesov!")
            else:
                st.info("üì≠ ≈Ωiadne procesy v Airtable")
                
    except Exception as e:
        st.error(f"‚ùå Chyba synchroniz√°cie: {e}")

def activate_airtable_mode(api_key: str, base_id: str):
    """Aktivuje Airtable re≈æim v aplik√°cii"""
    try:
        from airtable_connector import HybridDatabaseManager
        
        with st.spinner("üîÑ Aktivujem Airtable re≈æim..."):
            # Test pripojenia
            test_manager = HybridDatabaseManager(
                use_airtable=True,
                airtable_api_key=api_key,
                airtable_base_id=base_id
            )
            
            if test_manager.connection_ok:
                # Ulo≈æ nastavenia do session state
                st.session_state.use_airtable = True
                st.session_state.hybrid_db_manager = test_manager
                
                st.success("‚úÖ Airtable re≈æim aktivovan√Ω!")
                st.info("üîÑ Aplik√°cia teraz pou≈æ√≠va Airtable pre ukladanie nov√Ωch d√°t")
                st.balloons()
                
                # Zobraz status
                col1, col2 = st.columns(2)
                with col1:
                    st.metric("üìä Datab√°za", "Airtable (akt√≠vna)")
                with col2:
                    st.metric("üîó Pripojenie", "√öspe≈°n√©")
                    
            else:
                st.error("‚ùå Nemo≈æno aktivova≈• Airtable re≈æim - pripojenie ne√∫spe≈°n√©")
                
    except Exception as e:
        st.error(f"‚ùå Chyba aktiv√°cie: {e}") 